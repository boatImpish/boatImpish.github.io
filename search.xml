<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git最佳实践：Git Flow的使用</title>
    <url>/archives/a7060461.html</url>
    <content><![CDATA[<p>代码管理需要一个清晰的流程和规范</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/git-flow-navigation.png" alt="GitFlowNavigation"></p>
<h2 id="Git-Flow-常用分支"><a href="#Git-Flow-常用分支" class="headerlink" title="Git Flow 常用分支"></a>Git Flow 常用分支</h2><ul>
<li>Production 分支</li>
</ul>
<p>也就是我们常用的 master 分支，用来发布到生产环境的代码；这个分支只能从其他分支合并，不能在这个分支直接修改代码。</p>
<ul>
<li>Develop 分支</li>
</ul>
<p>这个分支是我们的主开发分支，包含所有要发布到下一个Release的代码，这个这个合并其他分支，比如Feature分支</p>
<ul>
<li>Feature 分支</li>
</ul>
<p>这个分支主要用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p>
<ul>
<li>Release 分支</li>
</ul>
<p>当你需要发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并Master和Develop分支</p>
<ul>
<li>Hotfix分支</li>
</ul>
<p>当我们再Production发现新的Bug时，我们需要创建一个Hotfix，完成Hotfix后，我们合并回master和Develop分支，所以Hotfix的改动会进入下一个Release</p>
<h2 id="Git-Flow如何工作"><a href="#Git-Flow如何工作" class="headerlink" title="Git Flow如何工作"></a>Git Flow如何工作</h2><h3 id="初始分支-master"><a href="#初始分支-master" class="headerlink" title="初始分支(master)"></a>初始分支(master)</h3><p>所有再master分支上的Commit应该Tag</p>
<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/git-workflow-release-cycle.png" alt="img"></p>
<h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>分支名feature/*</p>
<p>Feature分支做完后，必须合并回Develop分支，合并完分支后一般会删掉这个Feature分支。</p>
<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/git-workflow-release-cycle-2feature.png" alt="img"></p>
<h3 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h3><p>分支名release/*</p>
<p>Release分支基于Develop分支创建，打完Release分支后，我们可以在这个Release分支上测试，修改Bug等。同时，其他开发人员可以基于开发新的Feature发布Release分支时，合并Release到Master和Develop分支，同时在Master分支上打个Tag记住Release版本号，然后就可以删除Release分支了。</p>
<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/o_git-workflow-release-cycle-3release.png" alt="img"></p>
<h3 id="维护Hotfix"><a href="#维护Hotfix" class="headerlink" title="维护Hotfix"></a>维护Hotfix</h3><p>分支名hotfix/*</p>
<p>hotfix分支基于Master分支创建，开发完成后要合并会Master和Develop分支，同时在Master上打一个Tag。</p>
<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/o_git-workflow-release-cycle-4maintenance.png" alt="img"></p>
<h3 id="Git-Flow代码示例"><a href="#Git-Flow代码示例" class="headerlink" title="Git Flow代码示例"></a>Git Flow代码示例</h3><ol>
<li>创建develop分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin devlop</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开始新Feature开发</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b some-feature develop</span><br><span class="line"><span class="meta">#</span><span class="bash"> Optionally, push branch to origin:</span></span><br><span class="line">git push -u origin some-feature</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 做一些改动</span></span><br><span class="line">git status</span><br><span class="line">git add some-file</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>完成Feature</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no--ff some-feature</span><br><span class="line">git push origin develop</span><br><span class="line"></span><br><span class="line">git branch -d some-feature</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you pushed branch to origin:</span></span><br><span class="line">git push origin --delete some-feature</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开始Release</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b release-0.1.0 develop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Optional: Bump version number, commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Prepare release, commit</span>		</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>完成Release</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no--ff release-0.1.0</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no--ff release-0.1.0</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git branch -d release-0.1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you pushed branch to origin:</span></span><br><span class="line">git push origin --delete release-0.1.0</span><br><span class="line"></span><br><span class="line">git tag -a v0.1.0 master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>开始Hotfix</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b hotfix-0.1.1 master</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>完成Hotfix</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge --no--ff hotfix-0.1.1</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no--ff hotfix-0.1.1</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">git branch -d hotfix-0.1.1</span><br><span class="line"></span><br><span class="line">git tag -a v0.1.1 master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>从安卓手机中拉出Apk</title>
    <url>/archives/6f7bfefe.html</url>
    <content><![CDATA[<p>如何快速将安装到手机中的应用的Apk文件快速拿出来，使用下面几个ADB命令即可轻松做到。</p>
<span id="more"></span>

<h6 id="查看是否链接到手机"><a href="#查看是否链接到手机" class="headerlink" title="查看是否链接到手机"></a>查看是否链接到手机</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330225045870-16486596140232.png" alt="image20220330225045870"></p>
<h6 id="进入手机的shell层"><a href="#进入手机的shell层" class="headerlink" title="进入手机的shell层"></a>进入手机的shell层</h6><ul>
<li>单一设备链接时</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330225557489.png" alt="image-20220330225557489"></p>
<ul>
<li>多设备链接时</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb -s 手机设备序列号 shell</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330225818186.png" alt="image-20220330225818186"></p>
<h6 id="查看安装软件的包名"><a href="#查看安装软件的包名" class="headerlink" title="查看安装软件的包名"></a>查看安装软件的包名</h6><ul>
<li>查看所有软件的包名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm list packages</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330230040400.png" alt="image-20220330230040400"></p>
<ul>
<li>根据关键字查找包名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm list packages | grep oneplus</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330230331065.png" alt="image-20220330230331065"></p>
<h6 id="查看安装包的位置"><a href="#查看安装包的位置" class="headerlink" title="查看安装包的位置"></a>查看安装包的位置</h6><ul>
<li>查看所有安装包位置</li>
</ul>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pm list packages -f</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330230631200.png" alt="image-20220330230631200"></p>
<ul>
<li>查看符合包名要求的安装包位置</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">pm list packages -f <span class="string">| grep tencent</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330231047522.png" alt="image-20220330231047522"></p>
<h6 id="将Apk拉到PC本地"><a href="#将Apk拉到PC本地" class="headerlink" title="将Apk拉到PC本地"></a>将Apk拉到PC本地</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">adb pull 上一步获取到的位置信息 PC存储位置(相对于命令行)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330231534430.png" alt="image-20220330231534430"></p>
<p>PC 端文件(用户名文件下)</p>
<p><img src="https://raw.githubusercontent.com/boatImpish/BlogImage/master/img/image-20220330231658094.png" alt="image-20220330231658094"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java &amp; Android代码规范指南</title>
    <url>/archives/abf51d21.html</url>
    <content><![CDATA[<p>本文为<a href="https://google.github.io/styleguide/javaguide.html">Google Java 风格指南</a>的汉语翻译。无论你是个人开发还是团队协同开发，一个良好的代码规范，能够在项目当中发挥举足轻重的作用；它不仅能使你们的开发更加高效，而且还会减少BUG产生的几率，增强代码可维护性及稳定性。</p>
<p>遇到不理解的地方，一定要多看看谷歌的Java代码规范官方原文。多思考才能慢慢进步。</p>
<span id="more"></span>

<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>本文档是指导使用 <strong>Java</strong> 编写源代码的完全定义。 一个 <strong>Java</strong> <strong>源代码文件</strong>只有严格遵守这里的规则，才能被称作为 <strong>Google</strong> <strong>风格</strong>。</p>
<p>就像其他的编码风格指南，这些问题的覆盖空间不仅涵盖格式化的美学问题，还有一些传统和代码标准。本文档主要着重于通用的 <strong>hard-and-fast(确定不可改变的，不可避免，不可忽视)</strong> 规则，尽量避免一些非人性化的建议，无论是对人还是工具而言。</p>
<h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在这个文档中，除非有其他的声明：</p>
<ol>
<li>类是指普通的类、枚举类、接口和注解类型（<code>@Interface</code>）。</li>
<li>类中的成员可以是成员变量、构造器、方法、内部类，就是类中比较顶层的内容。</li>
<li>注释总是指具体实现的注释。使用 <strong>Javadoc</strong> 指代文档注释。</li>
</ol>
<h3 id="1-2-指南注释"><a href="#1-2-指南注释" class="headerlink" title="1.2 指南注释"></a>1.2 指南注释</h3><p>本文档中的代码片段只是实现本指南的一种方式，不应该用来直接作为规范。</p>
<h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件名由大写敏感的顶层类名和文件扩展 <strong>.java</strong>组成。</p>
<h3 id="2-2-编码格式"><a href="#2-2-编码格式" class="headerlink" title="2.2 编码格式"></a>2.2 编码格式</h3><p>源文件使用UTF-8编码格式。</p>
<h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h4><p>除了行结束符序列，ASCII水平空格字符（<code>0x20</code>，即空格）是源文件中唯一允许出现的空白字符，这意味着：</p>
<ol>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ol>
<h4 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h4><p>对于具有<a href="https://docs.oracle.com/javase/tutorial/java/data/characters.html">特殊转义序列</a>的任何字符（<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&quot;</code>, <code>\&#39;</code>, <code>//</code>），我们使用它的转义序列，而不是相应的<strong>八进制</strong>（比如 <code>\012</code>）或 <strong>Unicode</strong>（比如<code>\u000a</code>）转义。</p>
<h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于剩余的非 <strong>ASCII</strong> 字符，是使用实际的 <strong>Unicode</strong> 字符（例如， <code>∞</code>），还是使用等价的 <strong>Unicode</strong> 转义符（例如，<code>\u221e</code>），取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>在使用 <strong>Unicode</strong> 转义符或是一些实际的 <strong>Unicode</strong> 字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Example</strong></th>
<th><strong>Discussion</strong></th>
</tr>
</thead>
<tbody><tr>
<td>String unitAbbrev = “μs”;</td>
<td>Best: perfectly clear even without a comment.</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // “μs”</td>
<td>Allowed, but there’s no reason to do this.</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td>
<td>Allowed, but awkward and prone to mistakes.</td>
</tr>
<tr>
<td>String unitAbbrev = “\u03bcs”;</td>
<td>Poor: the reader has no idea what this is.</td>
</tr>
<tr>
<td>return ‘\ufeff’ + content; // byte order mark</td>
<td>Good: use escapes for non-printable characters, and comment if necessary.</td>
</tr>
</tbody></table>
<blockquote>
<p>永远不要因为害怕某些程序可能无法正确处理非 <strong>ASCII</strong> 字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，自然无法正确运行， 然后必须去解决这些问题就好了。</p>
</blockquote>
<h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>一个源文件包含（按顺序地）：</p>
<ol>
<li>许可证或版权信息（如有）</li>
<li><strong>Package</strong> 语句</li>
<li><strong>Import</strong> 语句</li>
<li>有且仅有一个<strong>顶级</strong>类</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h3 id="3-1-许可证或版权信息（如有）"><a href="#3-1-许可证或版权信息（如有）" class="headerlink" title="3.1 许可证或版权信息（如有）"></a>3.1 许可证或版权信息（如有）</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p><strong>Package</strong> 语句不会自动换行，列限制（4.4节，<strong>列限制：100</strong> ）并不适用于 <strong>Package</strong> 语句（即 <strong>Package</strong> 语句写在一行里）。</p>
<h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>不要出现类似这样的 <strong>Import</strong> 语句：<code>import java.util.*;</code></p>
<h4 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h4><p><strong>Import</strong> 语句不换行，列限制（4.4节，<strong>列限制：100</strong> ）并不适用于 <strong>Import</strong> 语句（即 <strong>Import</strong> 语句写在一行里）。</p>
<h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><strong>Import</strong> 语句按照以下规则排序：</p>
<ol>
<li>所有<strong>静态</strong>导入独立成块</li>
<li>所有<strong>非静态</strong>导入独立成块</li>
</ol>
<p>如果<strong>静态</strong>块和<strong>非静态</strong>块同时存在，用一个空行分隔。<strong>Import</strong>语句之间不会有多余的空行。</p>
<p>每个导入块之间的排列顺序按照 <strong>ASCII</strong> 排序。</p>
<h4 id="3-3-4-不要使用静态导入的类"><a href="#3-3-4-不要使用静态导入的类" class="headerlink" title="3.3.4 不要使用静态导入的类"></a>3.3.4 不要使用静态导入的类</h4><p>静态导入不适用静态内部类。他们要使用正常导入。</p>
<h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。<br>例外，<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>
<h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 </p>
<p>最重要的一点，每个类应该以<strong>某种逻辑</strong>去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。不受修饰符的影响。</p>
<h2 id="4-格式化"><a href="#4-格式化" class="headerlink" title="4 格式化"></a>4 格式化</h2><p>术语说明：块状结构指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构（<strong>4.8.3.1节</strong>）。</p>
<h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> 语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<p>其他的可选择大括号，例如 <code>lambda</code> 表达式中，保留可选择性。</p>
<h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循 <strong>Kernighan</strong> 和 <strong>Ritchie</strong> 风格（<strong>Egyptian brackets</strong>）：</p>
<ol>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 例如，</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (condition()) &#123;</span><br><span class="line">    method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherCondition()) &#123;</span><br><span class="line">      somethingElse();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      lastThing();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> x = foo();</span><br><span class="line">      frob(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.8.1节给出了enum类的一些例外。</p>
</blockquote>
<h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分（例如，<code>if/else</code> 或 <code>try/catch/finally</code>），即使大括号内没内容，右大括号也要换行。 例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is acceptable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is equally acceptable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is not acceptable: No concise empty blocks in a multi-block statement</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。（见<strong>4.1.2节</strong>中的代码示例）</p>
<h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p>
<h3 id="4-4-列限制：100"><a href="#4-4-列限制：100" class="headerlink" title="4.4 列限制：100"></a>4.4 列限制：100</h3><p>一个项目可以选择一行100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。<br>例外：</p>
<ol>
<li>不可能满足列限制的行（例如，<strong>Javadoc</strong> 中的一个长 <strong>URL</strong>，或是一个长的 <strong>JSNI</strong> 方法参考）。</li>
<li><strong>Package</strong> 和 <strong>Import</strong> 语句(见<strong>3.2节</strong>和<strong>3.3节</strong>)。</li>
<li>注释中那些可能被剪切并粘贴到 <strong>shell</strong> 中的命令行。</li>
<li>非常长的标识符。</li>
</ol>
<h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：代码否则已经要合法的占据一整行的情况下，这段代码就会被分成多行。这个活动称之为自动换行（<strong>line-wrapping</strong>）。<br>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h4 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h4><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li><p>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：</p>
<ol>
<li>点分隔符（<code>.</code>）</li>
<li>方法引用（<code>::</code>）</li>
<li>类型界限中的 <code>&amp;</code>（<code>&lt;T extends Foo &amp; Bar&gt;</code>）</li>
<li><code>catch</code> 块中的管道符号（<code>catch (FooException | BarException e)</code>）</li>
</ol>
</li>
<li><p>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。</p>
<ol>
<li>这条规则也适用于foreach语句中的分号。</li>
</ol>
</li>
<li><p>方法名或构造函数名与左括号留在同一行。</p>
</li>
<li><p>逗号（<code>,</code>）与其前面的内容留在同一行。</p>
</li>
<li><p><strong>lambda</strong> 箭头后不允许换行，除非后面跟着一个单语句。例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyLambda&lt;String, Long, Object&gt; lambda =</span><br><span class="line">    (String label, Long value, Object obj) -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate = str -&gt;</span><br><span class="line">    longExpressionInvolving(str);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格（注意：制表符不用于缩进。见<strong>2.3.1节</strong>）。<br>当存在连续自动换行时，缩进可能会多缩进不只4个空格（语法元素存在多级时）。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。<br>第<strong>4.6.3节</strong>水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>
<h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
<li>例外：枚举常量之间的空行见<strong>4.8.1节</strong>。</li>
</ul>
</li>
<li>要满足本文档中其他节的空行要求(比如，<strong>3节</strong>：<strong>源码文件结构</strong>，<strong>3.3节</strong>：<strong>import语句</strong>) </li>
</ol>
<p>一个单独的空行可以出现在任何地方，只要它能够改善源码的可读性，例如，在语句中间加空行整理代码，让代码变成逻辑上的子集合。一个空行出现在第一个成员或者初始化器之前，或者在最后一个成员或者初始化器之后，既不鼓励也不抨击这样的行为。</p>
<p>多个连续的空行是允许的，但没有必要这样做（我们也不鼓励这样做）。</p>
<h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和 <strong>Javadoc</strong> 用到单个空格，单个 <strong>ASCII</strong> 空格也出现在以下几个地方：</p>
<ol>
<li><p>分隔任何保留字与紧随其后的左括号（<code>(</code>），比如，<code>if</code>，<code>for</code>，或者 <code>catch</code>。</p>
</li>
<li><p>分隔任何保留字与其前面的右大括号（<code>&#125;</code>），比如，<code>else</code>，<code>catch</code>。</p>
</li>
<li><p>在任何左大括号前（<code>&#123;</code>），两个例外： </p>
<ul>
<li><code>@SomeAnnotation(&#123;a, b&#125;)</code>（不使用空格）</li>
<li> <code>String[][] x = &#123;&#123;"foo"&#125;&#125;;</code>（括号间没有空格，见下面的）</li>
</ul>
</li>
<li><p>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</p>
<ul>
<li>类型界限连接中的 <code>&amp;</code>（<code>&lt;T extends Foo &amp; Bar&gt;</code>）</li>
<li> catch块中的管道符号<code>|</code> <code>catch (FooException | BarException e</code>)</li>
<li>增强 <code>for</code> 语句（<code>foreach</code>）语句中的分号（<code>:</code>）。</li>
<li><strong>lambda</strong> 表达式中的箭头符号：<code>(String str) -&gt; str.length()</code></li>
</ul>
<p>不适用于：</p>
<ul>
<li>双引号（<code>::</code>）的方法引用，写法例如：<code>Object::toString</code></li>
<li>点分割符号（<code>.</code>），写法例如：<code>object.toString()</code></li>
</ul>
</li>
<li><p>在 <code>, : ;</code> 及转型的右括号（<code>(</code>）后</p>
</li>
<li><p>在任何内容和双斜杠（<code>//</code>）之间，双斜杠之后就是注释。允许多个空格。</p>
</li>
<li><p>在双斜杠（<code>//</code>）和注释之间。允许多个空格。</p>
</li>
<li><p>声明时，在类型和变量之间：<code>List&lt;String&gt; list</code></p>
</li>
<li><p>数组初始化中，大括号内的空格是可选的</p>
<ul>
<li><code>new int[] &#123;5, 6&#125;</code> 和 <code>new int[] &#123; 5, 6 &#125;</code> 都是有效的</li>
</ul>
</li>
<li><p>在类型注解和 <code>[]</code> 、<code>...</code> 之间。 （我也不知道他这个时什么意思，先相信）</p>
</li>
</ol>
<p>这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
<h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。<br>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。<br>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和 <strong>reviewer</strong> 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h3 id="4-8-特定结构"><a href="#4-8-特定结构" class="headerlink" title="4.8 特定结构"></a>4.8 特定结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。额外的空行（通常只有一个）也是被允许的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Answer</span> </span>&#123;</span><br><span class="line">  YES &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  NO,</span><br><span class="line">  MAYBE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>没有方法和文档的枚举类可写成数组初始化的格式（见<strong>4.8.3.1节</strong>，<strong>数组初始化</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure>

<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不论成员还是局部变量，每次只声明一个变量，不要使用组合声明：声明比如：<code>int a, b;</code> 是不被允许的。</p>
<p>例外情况：多变量声明在 <code>for</code> 循环头部是可接受的。</p>
<h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了，而是在第一次需要使用它时才声明，减小他们的范围。 局部变量最好在声明时就进行初始化，或者声明后尽快进行初始化。</p>
<h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是有效的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>，而非 <code>String args[]</code>。</p>
<h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个 <strong>switch</strong> 标签（<code>case FOO:</code>或<code>default:</code>），后面跟着一条或多条语句。</p>
<h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，<strong>switch</strong> 块中的内容缩进为2个空格。 每个 <strong>switch</strong> 标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h5 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h5><p>在一个switch块内，每个语句组要么通过 <code>break</code>，<code>continue</code>，<code>return</code> 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是足够的（典型的是用 <code>// fall through</code>）。这个特殊的注释并不需要在最后一个语句组（一般是 <code>default</code>）中出现。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下，<code>case 1</code> 后面不需要注释，只有在每个语句组的结尾才需要。</p>
<h5 id="4-8-4-3-default-存在的情况"><a href="#4-8-4-3-default-存在的情况" class="headerlink" title="4.8.4.3 default 存在的情况"></a>4.8.4.3 default 存在的情况</h5><p>每个 <strong>switch</strong> 语句都包含一个 <code>default</code> 语句组，即使它什么代码也不包含。</p>
<p>例外情况：枚举类型的 <strong>switch</strong> 语句可以省略 <code>default</code> 语句组，如果已经详细列出了它的所有可能。这将保证 <strong>IDE</strong> 代码检测工具不会报警报。</p>
<h3 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h3><h4 id="4-8-5-1-类型使用注解"><a href="#4-8-5-1-类型使用注解" class="headerlink" title="4.8.5.1 类型使用注解"></a>4.8.5.1 类型使用注解</h4><p>类型使用立即出现在被注解的类型之前。一个注解是类型使用的是指它的元注解是 <code>@Target(ElementType.TYPE_USE</code>)。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="meta">@Nullable</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Person <span class="title">getPersonByName</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-5-2-类注解"><a href="#4-8-5-2-类注解" class="headerlink" title="4.8.5.2 类注解"></a>4.8.5.2 类注解</h4><p>类注解立即出现在文档块之后，每一个注解都单独成行，也就是注解行。这些换行不属于自动换行（<strong>4.5节</strong>，<strong>Line-Wrapping</strong>），所以缩进等级不会提高。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@CheckReturnValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Frozzler</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-5-3-方法和构造器注解"><a href="#4-8-5-3-方法和构造器注解" class="headerlink" title="4.8.5.3 方法和构造器注解"></a>4.8.5.3 方法和构造器注解</h4><p>使用方法同上节。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>例外情况</strong>：单个无参数的注解可以和签名的第一行出现在一起。例如：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-5-4-字段注解"><a href="#4-8-5-4-字段注解" class="headerlink" title="4.8.5.4 字段注解"></a>4.8.5.4 字段注解</h4><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-5-5-参数和局部变量的注解"><a href="#4-8-5-5-参数和局部变量的注解" class="headerlink" title="4.8.5.5 参数和局部变量的注解"></a>4.8.5.5 参数和局部变量的注解</h4><p>参数和局部变量注解没有特定规则（除非这个注解是类型使用注解）。</p>
<h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><p>本节重点在于代码注释的实现。<strong>Javadoc</strong> 相关见<strong>7节</strong>，<strong>Javadoc</strong>。</p>
<h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>块注释与其周围的代码在同一缩进级别。它们可以是 <code>/* ... */</code> 风格，也可以是 <code>// ...</code> 风格。对于多行的 <code>/* ... */</code> 注释，后续行必须从 <code>*</code> 开始， 并且与前一行的 <code>*</code> 对齐。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is          // And so           /* Or you can</span></span><br><span class="line"><span class="comment"> * okay.            // is this.          * even do this. */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>不能再注释里面写注释。</p>
<blockquote>
<p>小贴士：多行注释使用 <code>/* ... */</code> 风格，这样格式化的时候会自动换行。大多数的格式化插件下，单行注释 <code>// ...</code> 块不会自动换行。</p>
</blockquote>
<h5 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h5><p>类和成员的 **modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">default</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure>

<h4 id="4-8-8-数字字义"><a href="#4-8-8-数字字义" class="headerlink" title="4.8.8 数字字义"></a>4.8.8 数字字义</h4><p><code>long</code> 值的整型字义使用大写的 <code>L</code> 后缀，永远不要使用小写 <code>l</code>。例如，<code>300000000000L</code> 而不是 <code>300000000000l</code>。</p>
<h2 id="5-命名"><a href="#5-命名" class="headerlink" title="5 命名"></a>5 命名</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字,在如下极少数情况下使用下划线。因此每个有效的标识符名称都能匹配正则表达式\w+。<br>在 <strong>Google</strong> 风格中，特殊前缀和后缀不再使用。例如，这些命名都不是 <strong>Google</strong> 风格：<code>name_</code>, <code>mName</code>(这个Android 成员变量好像一直在用233), <code>s_name</code>和<code>kName</code>。</p>
<h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：<code>com.example.deepspace</code>, 不是 <code>com.example.deepSpac</code> 或者 <code>com.example.deep_space</code>。</p>
<h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以 <strong>UpperCamelCase</strong> 风格编写。<br>类名通常是名词或名词短语。例如：<code>Character</code> 或者 <code>ImmutableList</code> 。接口名可以也是名词或名词性短语;例如：<code>List</code>；但有时可能是形容词或形容词短语，例如：<code>Readable</code>。</p>
<p>现在还没有特定的规则或行之有效的约定来命名注解类型。<br>测试类名以 <code>Test</code> 结束,例如，<code>HashIntegrationTest</code>。如果要测试的是一个单类，命名就要用单类名加上 <code>Test</code>，例如，<code>HashImplTest</code>。</p>
<h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名使用 <code>lowerCamelCase</code> 风格编写。<br>方法名通常是动词或动词短语。例如：<code>sendMessage</code> 或者 <code>stop</code>。<br>下划线可能出现在 <strong>JUnit</strong> 测试方法名称中用以分隔名称的逻辑组件，其中每个组件都要使用 <code>lowerCamelCase</code>，例如，<code>transforMoney_deductsFromSource</code> 。测试方法命名不止 一种正确方式。</p>
<h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名使用 <strong>UPPER_SNAKE_CASE</strong>：全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？<br>常量都是 <strong>静态</strong> <code>final</code> 字段，其内容都是深度不可变的，其包含的方法不会有任何可检测的副作用。例如：<code>primitives</code>，字符串，值不可变的类，或者是任何设置成 <code>null</code> 的变量。如果任何一个实例的可观测状态是可变的，那它就不是一个常量。仅仅只是意图永远不去改变一个对象是不够的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">&quot;Ed&quot;</span>, <span class="string">&quot;Ann&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; AGES = ImmutableMap.of(<span class="string">&quot;Ed&quot;</span>, <span class="number">35</span>, <span class="string">&quot;Ann&quot;</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">&quot;non-final&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">&quot;non-static&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">&quot;these&quot;</span>, <span class="string">&quot;can&quot;</span>, <span class="string">&quot;change&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这些名字通常是名词或名词短语。</p>
<h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名（静态或其他）使用 <code>lowerCamelCase</code> 风格编写。<br>这些名字通常是名词或名词短语。例如，<code>computeValues</code> 或者 <code>index</code>。</p>
<h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名使用 <code>lowerCamelCase</code> 风格编写。<br>参数应该避免用单个字符命名。</p>
<h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名使用 <code>lowerCamelCase</code> 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。<br>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p>
<ol>
<li>单个的大写字母，后面可以跟一个数字(例如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li>
<li>以类命名方式（见<strong>5.2.2节</strong>），后面加个大写的 <code>T</code>（例如：<code>RequestT</code>, <code>FooBarT</code>）。</li>
</ol>
<h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法（<strong>UpperCamelCase</strong>）和小驼峰式命名法（<strong>lowerCamelCase</strong>）。 有时，有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构，例如，<code>IPv6</code> 或 <code>iOS</code>。为了改善可预测性，<strong>Google</strong> 风格指定了以下近乎确定的方案。</p>
<p>名字从散文形式(prose form)开始:</p>
<ol>
<li><p>把短语转换为纯ASCII码，并且移除任何所有格符号。例如，<code>&quot;Müller’s algorithm</code> 将变成 <code>Muellers algorithm</code>。</p>
</li>
<li><p>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</p>
<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开（如 <code>AdWords</code> 将分割成 <code>ad words</code>）。 需要注意的是 <code>iOS</code> 并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
</li>
<li><p>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</p>
<ul>
<li><p>每个单词的第一个字母都大写，来得到大驼峰式命名。</p>
</li>
<li><p>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</p>
</li>
</ul>
</li>
<li><p>最后将所有的单词连接起来得到一个标识符。</p>
</li>
</ol>
<p>例如：</p>
<table>
<thead>
<tr>
<th>Prose form</th>
<th>Correct</th>
<th>Incorrect</th>
</tr>
</thead>
<tbody><tr>
<td>“XML HTTP request”</td>
<td><code>XmlHttpRequest</code></td>
<td>XMLHTTPRequest</td>
</tr>
<tr>
<td>“new customer ID”</td>
<td><code>newCustomerId</code></td>
<td>newCustomerID</td>
</tr>
<tr>
<td>“inner stopwatch”</td>
<td><code>innerStopwatch</code></td>
<td>innerStopWatch</td>
</tr>
<tr>
<td>“supports IPv6 on iOS?”</td>
<td><code>supportsIpv6OnIos</code></td>
<td>supportsIPv6OnIOS</td>
</tr>
<tr>
<td>YouTube importer”</td>
<td><code>YouTubeImporter</code> <br /> <code>YoutubeImporter</code>*</td>
<td></td>
</tr>
</tbody></table>
<p>加星号处表示可以接受，但不推荐。</p>
<blockquote>
<p>小贴士：有些单词在英语中被隐式的连字符连接起来。例如，<strong>nonempty</strong> 和 <strong>non-empty</strong> 都是正确的，所以方法名 <code>checkNonempty</code> 和 <code>checkNonEmpty</code> 两者同样都是正确的。</p>
</blockquote>
<h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 @Override：总是使用</h3><p>只要是合法的，就把@Override注解给用上。包括负载的父类方法，实现的接口方法，接口中继承父类接口的方法。</p>
<p>例外：<code>@override</code> 在父类方法被标注为 <code>@Deprecated</code> 时是可以被忽略不写的。</p>
<h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 <code>AssertionError</code> 重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">  <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">  <span class="comment">// it&#x27;s not numeric; that&#x27;s fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure>

<p>例外：在测试中，如果一个捕获的异常被命名为 <code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-静态成员：使用类授权调用"><a href="#6-3-静态成员：使用类授权调用" class="headerlink" title="6.3 静态成员：使用类授权调用"></a>6.3 静态成员：使用类授权调用</h3><p>如果一个静态类的引用一定要授权，那么使用类名授权，即使用类名调用静态的类成员，而不是具体某个对象或返回对象的表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重载 <code>Object.finalize</code>。</p>
<blockquote>
<p>不要使用 <code>finalize</code>。如果你非要使用它，请先仔细阅读和理解 <strong>Effective Java</strong> 第7条款：<strong>Avoid Finalizers</strong>，然后不要使用它。</p>
</blockquote>
<h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><strong>Javadoc</strong> 块的基本格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>或者是以下单行形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure>

<p>基本格式总是能接受的。当整个 <strong>Javadoc</strong> 块能容纳于一行时(包括注释标注)，可以使用单行形式。注意，这仅仅适用于没有 <strong>Javadoc</strong> 标记 <code>@XXX</code> 的情况，例如： <code>@return</code>。</p>
<h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即只包含最左侧星号(*)的行)会出现在段落之间和 <strong>Javadoc</strong> 标记( <code>@XXX</code> )(如果有的话)之前。 除了第一个段落，每个段落第一个单词前都有标签 <code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。其他块级元素的 <strong>HTML</strong> 标签前面不用加 <code>&lt;p&gt;</code>, 例如：<code>&lt;ul&gt;</code> 或者 <code>&lt;table&gt;</code>。</p>
<h4 id="7-1-3-块标签"><a href="#7-1-3-块标签" class="headerlink" title="7.1.3 块标签"></a>7.1.3 块标签</h4><p>标准的块标签按以下顺序出现：<code>@param</code>,  <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少在 <code>@</code> 再缩进4个空格。e.g.:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">/<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"> <span class="symbol">*</span> Called when the activity is starting.  This is where most initialization</span><br><span class="line"> <span class="symbol">*</span> should go: calling &#123;<span class="meta">@link</span> <span class="comment">#setContentView(int)&#125; to inflate the</span></span><br><span class="line"> <span class="symbol">*</span> activity&#x27;s UI, using &#123;<span class="meta">@link</span> <span class="comment">#findViewById&#125; to programmatically interact</span></span><br><span class="line"> <span class="symbol">*</span> with widgets in the UI, calling</span><br><span class="line"> <span class="symbol">*</span> &#123;<span class="meta">@link</span> <span class="comment">#managedQuery(android.net.Uri , String[], String, String[], String)&#125; to retrieve</span></span><br><span class="line"> <span class="symbol">*</span> cursors for data being displayed, etc.</span><br><span class="line"> <span class="symbol">*</span></span><br><span class="line"> <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span>You can call &#123;<span class="meta">@link</span> <span class="comment">#finish&#125; from within this function, in</span></span><br><span class="line"> <span class="symbol">*</span> which case onDestroy() will be immediately called after &#123;<span class="meta">@link</span> <span class="comment">#onCreate&#125; without any of the</span></span><br><span class="line"> <span class="symbol">*</span> rest of the activity lifecycle (&#123;<span class="meta">@link</span> <span class="comment">#onStart&#125;, &#123;@link #onResume&#125;, &#123;@link #onPause&#125;, etc)</span></span><br><span class="line"> <span class="symbol">*</span> executing.</span><br><span class="line"> <span class="symbol">*</span></span><br><span class="line"> <span class="symbol">*</span> <span class="variable">&lt;p&gt;</span><span class="variable">&lt;em&gt;</span>Derived classes must call through to the super class&#x27;s</span><br><span class="line"> <span class="symbol">*</span> implementation of this method.  If they do not, an exception will be</span><br><span class="line"> <span class="symbol">*</span> thrown.<span class="variable">&lt;/em&gt;</span><span class="variable">&lt;/p&gt;</span></span><br><span class="line"> <span class="symbol">*</span></span><br><span class="line"> <span class="symbol">*</span> <span class="meta">@param</span> savedInstanceState If the activity is being re-initialized after</span><br><span class="line"> <span class="symbol">*</span>     previously being shut down then this Bundle contains the data it most</span><br><span class="line"> <span class="symbol">*</span>     recently supplied in &#123;<span class="meta">@link</span> <span class="comment">#onSaveInstanceState&#125;.  &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt;</span></span><br><span class="line"> <span class="symbol">*</span></span><br><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#onStart</span></span><br><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#onSaveInstanceState</span></span><br><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#onRestoreInstanceState</span></span><br><span class="line"> <span class="symbol">*</span> <span class="meta">@see</span> <span class="comment">#onPostCreate</span></span><br><span class="line"> <span class="symbol">*</span>/</span><br></pre></td></tr></table></figure>



<h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个 <strong>Javadoc</strong> 块以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，比如在类和方法索引中，它是唯一出现的文本。 </p>
<p>这就是一个片段，可以是一个名词短语或动词短语，不是一个完整的句子。它不会以 <code>A &#123;@code Foo&#125; is a...</code> 或 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>小贴士：一个常见的错误是把简单的Javadoc写成 <code>/** @return the customer ID */</code>，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个 <code>public</code> 类及它的每个 <code>public</code> 和 <code>protected</code> 成员上使用Javadoc，以下是一些例外：</p>
<p>额外的 <strong>Javadoc</strong> 内容也可以展示，<strong>7.3.3</strong> 章节会解释。</p>
<h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的成员如 <code>getFoo()</code>， <strong>Javadoc</strong> 是可选的。这种情况下除了写 <code>Returns the foo</code>，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>重要小贴士：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。</p>
</blockquote>
<h3 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h3><p>如果一个方法重载了超类中的方法，那么 <strong>Javadoc</strong> 并非必需的。</p>
<h3 id="7-3-3-非必需Javadoc"><a href="#7-3-3-非必需Javadoc" class="headerlink" title="7.3.3 非必需Javadoc"></a>7.3.3 非必需Javadoc</h3><p>其他的类或者成员已经有了需要的 <strong>Javadoc</strong>。</p>
<p>非必需 <strong>Javadoc</strong> 不需要严格遵守 <strong>7.1.1</strong> <strong>7.1.2</strong> <strong>7.1.3</strong> 和 <strong>7.2</strong> 的格式化规则，尽管我们的建议还是按照规则来做。</p>
<h2 id="8-Android部分"><a href="#8-Android部分" class="headerlink" title="8 Android部分"></a>8 Android部分</h2><h3 id="8-1-代码命名规则"><a href="#8-1-代码命名规则" class="headerlink" title="8.1 代码命名规则"></a>8.1 代码命名规则</h3><ol>
<li><p><code>Activity</code> 命名一律使用 <strong>功能名+Activity</strong> 的方式。例如：<code>LoginActivity</code>、<code>SignupActivity</code>。</p>
</li>
<li><p><code>Fragment</code> 命名一律使用 <strong>功能名+Fragment</strong> 的方式。例如：<code>HomeFragment</code>、<code>MineFragment</code>。</p>
</li>
<li><p><strong>自定义</strong><code>View</code>：**Custom(建议)+功能名+View/ViewGroup(具体的组件名称)**。例如：<code>CustomImageScroller</code>、<code>CustomRatingBar</code>。</p>
</li>
<li><p><code>Widget</code> 命名一律使用 <strong>功能名 + Widget</strong>。例如： <code>ScanWidget</code>、<code>WeatherWidget</code>。</p>
</li>
<li><p><code>Dialog</code> <strong>对话框</strong>：<strong>功能名+Dialog</strong>。例如：LoginDialog、ProgressDialog。</p>
</li>
<li><p>尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息</p>
<blockquote>
<p>Tip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量)。</p>
</blockquote>
</li>
<li><p>对于使用Intent传递数据，声明一些 <strong>Key</strong> 的时候：</p>
<blockquote>
<p><strong>EXTRA_KEY_+具体Key名称</strong>，例如我们现在有一个人的名字和年龄要传那么首先定义：</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_KEY_PERSON_NAME=<span class="string">&quot;EXTRA_KEY_PERSON_NAME&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_KEY_PERSON_AGE=<span class="string">&quot;EXTRA_KEY_PERSON_AGE&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在具体的页面 <code>new Intent()</code>，依次传递进去值，这样写其实没什么问题；但是试想一下，如果你要调用的Activity是类似于一个工具性质或通用的 <code>Activity</code>（图片选择器、登录、注册等等），这时候你要传递的 <strong>Key</strong> 又很多，如果业务复杂的话，你应该会被这样冗余且不易阅读的代码直接搞崩溃掉。</p>
<p>所以最好的办法就是在你要调用Activity提供一个静态工厂方法，要知道静态工厂方法所带来的好处太多了，由于 <code>Activity</code> 是不允许通过 <code>new</code> 的方式来初始化的，所以静态工厂方法的好处在此就不那么明显，但是已经足够我们优化我们的代码了。举个例子，我们有一个笔记 <code>NoteActivity</code>，用于创建笔记和修改笔记，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//笔记Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_KEY_NOTE_ID =<span class="string">&quot;EXTRA_KEY_NOTE_ID&quot;</span> ;</span><br><span class="line"><span class="comment">//笔记内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_KEY_NOTE_CONTENT =<span class="string">&quot;EXTRA_KEY_NOTE_CONTENT&quot;</span> ;</span><br><span class="line"><span class="comment">//笔记模式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_KEY_NOTE_MODE =<span class="string">&quot;EXTRA_KEY_NOTE_MODE&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于创建笔记</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startForCreate</span><span class="params">(Context context, <span class="keyword">int</span> noteId)</span> </span>&#123;</span><br><span class="line">  start(context, noteId, <span class="keyword">null</span>, MODE_CREATE);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//用于编辑笔记</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startForEdit</span><span class="params">(Context context, <span class="keyword">int</span> noteId, String content)</span> </span>&#123;</span><br><span class="line">  start(context, noteId, content, MODE_UPDATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Context context, <span class="keyword">int</span> noteId, String content, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">  Intent starter = <span class="keyword">new</span> Intent(context, TableShareListSettingActivity.class);</span><br><span class="line">  starter.putExtra(EXTRA_KEY_NOTE_ID,noteId);</span><br><span class="line">  starter.putExtra(EXTRA_KEY_NOTE_CONTENT,content);</span><br><span class="line">  starter.putExtra(EXTRA_KEY_NOTE_CONTENT,mode);</span><br><span class="line">  context.startActivity(starter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上方法，我们能够很好的解耦复杂的 <code>Activity</code> 之间的调用，再加上静态方法工厂方法名，代码可阅读行大大提高，最终我们看到的调用 <code>NoteActivity</code> 将会是很简洁的一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NoteActivity.startForCreate(<span class="keyword">this</span>,noteId);</span><br><span class="line">NoteActivity.startForEdit(<span class="keyword">this</span>,noteId,content);</span><br></pre></td></tr></table></figure>

<p>此外，<strong>Android Studio</strong> 工具中其实已经在 <strong>Live Template</strong> 中提供了这样的代码: <strong>CMD+J( For MAC OS)</strong> ,简单的输入<code>starter</code>就可以快速地在当前的Activity中添加一个 <code>Intent</code> 的静态操作方法，这其实也说明了 <strong>Android</strong> 官方团队也鼓励我们这么做。</p>
<ol>
<li><code>Activity</code> 中变量采用m开头+类名。例如，<code>mTable</code>、<code>mPerson</code>；</li>
<li><code>Activity</code>中的控件：<code>m + 控件类型名称缩写 + 模块名</code>。例如，mEtLogin,mTvLogin;</li>
</ol>
<h3 id="8-2-资源-Res"><a href="#8-2-资源-Res" class="headerlink" title="8.2 资源 Res"></a>8.2 资源 <strong>Res</strong></h3><p>按照资源的类型，分为以下几种:</p>
<h4 id="8-2-1-控件Id命名"><a href="#8-2-1-控件Id命名" class="headerlink" title="8.2.1 控件Id命名"></a>8.2.1 <strong>控件Id命名</strong></h4><p><strong>控件缩写 _模块（module) _功能名(function)</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">控件类型	        ID命名规则</span><br><span class="line">TextView	tv_module_function</span><br><span class="line">EditText	et_module_function</span><br><span class="line">ImageView	iv_module_function</span><br><span class="line"><span class="keyword">Button	</span>        <span class="keyword">btn_module_function</span></span><br><span class="line"><span class="keyword"></span>ListView	lv_module_function</span><br><span class="line">GridView	gv_module_function</span><br><span class="line">CheckBox	check_module_function</span><br><span class="line">RadioButton	radio_module_function</span><br><span class="line">LinearLayout	<span class="keyword">ll_module_function</span></span><br><span class="line"><span class="keyword"></span>RelativeLayout  rl_module_function</span><br><span class="line">FrameLayout	fl_module_function</span><br><span class="line">GridLayout	gl_module_function</span><br></pre></td></tr></table></figure>

<h4 id="8-2-2-Color资源命名"><a href="#8-2-2-Color资源命名" class="headerlink" title="8.2.2 Color资源命名"></a>8.2.2 <strong>Color资源命名</strong></h4><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">Resources <span class="built_in">Type</span>	命名规则</span><br><span class="line"><span class="built_in">color</span>	组件名+模块名+具体作用名。例 R.<span class="built_in">color</span>.login_button_text</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-String资源命名"><a href="#8-2-3-String资源命名" class="headerlink" title="8.2.3 String资源命名"></a>8.2.3 <strong>String资源命名</strong></h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Resources Type	命名规则</span><br><span class="line"><span class="built_in">string</span>	模块名+具体功能。 例 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span><span class="built_in">string</span>.login_hello</span><br></pre></td></tr></table></figure>

<h4 id="8-2-4-Drawable资源命名"><a href="#8-2-4-Drawable资源命名" class="headerlink" title="8.2.4 Drawable资源命名"></a>8.2.4 <strong>Drawable资源命名</strong></h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Resources Type	命名规则</span><br><span class="line">launcher icon	ic_launcher。例<span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>drawable.ic_launcher</span><br><span class="line">normal icon	具体模块_ic_功能。例<span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>drawable.ic_audio_pause</span><br><span class="line">Toolbar icon 具体模块_ic_tb_功能名。例如login_ic_tb_search</span><br><span class="line">selector	selector_模块_功能名。例如 selector_login_button</span><br><span class="line">shape	shape_模块功能名状态。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>drawable.shape_login_button_normal</span><br></pre></td></tr></table></figure>

<h4 id="8-2-5-Layout资源命名"><a href="#8-2-5-Layout资源命名" class="headerlink" title="8.2.5 Layout资源命名"></a>8.2.5 <strong>Layout资源命名</strong></h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">类型	命名规则</span><br><span class="line">activity	activity_功能名。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.activity_login</span><br><span class="line">fragment	fragment_功能名。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.fragment_login_layout_header</span><br><span class="line"><span class="keyword">include</span>	layout_模块名_功能名。例如 @layout/layout_login_bottom</span><br><span class="line">adapter	adapter_item_模块名_功能名。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.adapter_item_simple_text</span><br><span class="line">dialog	dialog_模块_功能名。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.dialog_time_picker</span><br><span class="line"><span class="built_in">list</span> header	header_模块_功能。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.header_login_top_ad</span><br><span class="line"><span class="built_in">list</span> footer	footer_模块_功能。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.footer_login_bottom_action</span><br><span class="line">widget	widget_模块_功能。例如 <span class="module-access"><span class="module"><span class="identifier">R</span>.</span></span>layout.widget_login_clock</span><br></pre></td></tr></table></figure>

<h4 id="8-2-6-Menu资源命名"><a href="#8-2-6-Menu资源命名" class="headerlink" title="8.2.6 Menu资源命名"></a>8.2.6 <strong>Menu资源命名</strong></h4><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Resources <span class="keyword">Type</span>	<span class="type">命名规则</span></span><br><span class="line"><span class="type"></span>menu	menu_模块名。例如 menu_login</span><br></pre></td></tr></table></figure>

<h4 id="8-2-7-Values资源命名"><a href="#8-2-7-Values资源命名" class="headerlink" title="8.2.7 Values资源命名"></a>8.2.7 <strong>Values资源命名</strong></h4><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Resources</span> <span class="built_in">Type</span>	命名规则</span><br><span class="line">color	模块名<span class="variable">_color</span>。例如 material_design_color</span><br><span class="line">dimens	模块名<span class="variable">_dimens</span>。例如 material_design_dimens</span><br><span class="line">style	模块名<span class="variable">_style</span>。例如 material_design_style</span><br><span class="line">themes	模块名<span class="variable">_themes</span>。例如 material_design_themes</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>Code Style</tag>
      </tags>
  </entry>
  <entry>
    <title>常见古英语单词对照</title>
    <url>/archives/db3cdaed.html</url>
    <content><![CDATA[<p>读十四行诗必备~</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">古英语</th>
<th align="center">现代英语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">thou</td>
<td align="center">主格you</td>
</tr>
<tr>
<td align="center">thy</td>
<td align="center">your</td>
</tr>
<tr>
<td align="center">oft</td>
<td align="center">often</td>
</tr>
<tr>
<td align="center">tho’</td>
<td align="center">though</td>
</tr>
<tr>
<td align="center">thine</td>
<td align="center">yours</td>
</tr>
<tr>
<td align="center">hither</td>
<td align="center">here</td>
</tr>
<tr>
<td align="center">wi’</td>
<td align="center">with</td>
</tr>
<tr>
<td align="center">hath</td>
<td align="center">has</td>
</tr>
<tr>
<td align="center">o’</td>
<td align="center">of</td>
</tr>
<tr>
<td align="center">doth</td>
<td align="center">does</td>
</tr>
<tr>
<td align="center">e’en</td>
<td align="center">even</td>
</tr>
<tr>
<td align="center">o’er</td>
<td align="center">over</td>
</tr>
<tr>
<td align="center">art</td>
<td align="center">are</td>
</tr>
<tr>
<td align="center">thee</td>
<td align="center">宾格you</td>
</tr>
</tbody></table>
]]></content>
  </entry>
</search>
